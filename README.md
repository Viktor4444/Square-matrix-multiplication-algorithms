# Square-matrix-multiplication-algorithms
## Алгоритмы умножение матриц

### Задача
Напишите функцию, которая принимает две квадратные (NxN) матрицы (двумерные массивы) и возвращает их произведение. Будут даны только квадратные матрицы.


### Описание проекта
В задаче необходимо реализовать только один алгоритм, но стандартный алгоритм умножения матриц не очень интересный. Поэтому я решил опробовать несколько алгоритмов. А в качестве котрольной точки решил замерить скорость работы этих алгоритмов.


**В условиях задачи подразумевалось использование только стандартной библиотеки Python, без numpy и прочих библиотек для работы с данных и/или математикой. Но я решил сравнить скорость работы и со стандартным алгоитмом numpy. Так же алгоритм Штрассена был релизован с некоторыми функциями numpy в целях экономии времени написания кода.*


**Файл, в котором демонстрируется решение задачи - `test.py`. В нём вызывается реализация стандартного решения алгоритма и результат умножения матриц выводится на экран.**


Файл `performance_time_test.py` - реализация теста времени работы разных алгоритмов. Тест полуавтоматический. При добавлении нового алгоритма в файл с алгоритмами `matrix_multiplication_algorithms.py` необходимо будет всего лишь импортировать этот алгоритм в файл для тестриования и вписать в словарь `methods` название алгоритма и саму функцию (обязательное условие - сигнатура функции должна состоять из двух аргументов-матриц. Если это двумерные списки Python - то дополнительно необходимо добавить название метода как в словаре в список `without_numpy_methods`, если это массивы numpy - то не нужно).


Так же в репозитрии есть файл `compare_result.csv`, в котором представлена информация о времени работы алгоритмов на матрицах размера степени двойки от 2 до 512. Фрагмент таблицы:
...
| square matrix size  | native | one stroke  | numpy emplemented |strassen numpy |
| ------------- | ------------- |------------- | ------------- | ------------- |
| 32  |0.0069825649	| 0.0059525967| 0.0000000000	|0.0418889523|
| 64  | 0.0748000145 | 0.0528588295 |	0.0000000000 | 0.2473371029 |
| 128  | 0.4513399601 | 0.4413571358 | 0.0049860477 | 1.7713453770  |
...

В колонке **square matrix size** указан размер матрицы, в остальных колонках время работы этих алгоритмов в секундах под соотвествующими названиями.


Чему я был удивлён - это времени работы метода [`numpy.matmul`](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html). Реализация на плюсах даёт о себе знать :).
А вот что меня озадачило - это врем работы алоритма Штрассена. Он должен работать быстрее чем нативный агоритм ~~*(если, конечно, я не накосячил)*~~. Но, как я понимаю, для этого нужен тест для бОльших размеров матриц (на моём домашнем железе это слишком долго). А так же его можно отлично распараллелить (вот [тут](https://habr.com/ru/articles/313258/) есть отличная статейка с реализацией на Java и с красивыми графиками).


**Кстати, о графиках - думаю, можно и сюда прикрутить что-нибудь наглядно-показательное :)*